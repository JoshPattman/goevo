# GoEvo Rewrite
This branch is an experimental rewrite from the ground up. I am making it as fast, simple, and bug-free as possible.

# GoEvo - Evolutionary Algorithms Based on NEAT, in Golang
GoEvo is a package for Go that performs a variety of evolutionary algorithms to optimise a neural network. The networks do not only evolve their weights, but also the neurons within, and therefore their whole structure. I have tried to base GoEvo networks on the ones described in the original NEAT paper, [Evolving Neural Networks Through Augmenting Topologies](https://nn.cs.utexas.edu/downloads/papers/stanley.ec02.pdf), however, I have taken some liberties during development. Despite this, the networks function in broadly the same way as originally described.

GoEvo also does not just support the NEAT algorithm. NEAT genotypes can be used with many other types of genetic algorithms, with various methods of selection, mutation, and speciation. For this reason, GoEvo strives to support many different algorithms, all focusing on optimising the genotype type, which equates to DNA. GoEvo is also built to be very extensible, allowing the user to implement new evolutionary processes with ease.

## About NEAT
NeuroEvolution of Augmenting Topologies (NEAT) is an algorithm to grow neural networks optimised for a specific task. Instead of traditional machine learning, NEAT is not usually used in a supervised manner where the correct answer is always known, but instead tends to be used in scenarios like controlling a robot to walk, where there is no _correct_ solution to the problem.

There are two main components to NEAT:
- Genotype/phenotype: A genotype represents DNA, and can be crossed over and mutated. A phenotype is the brain that results from _compiling_ the genotype. The phenotype is the part that can take a set of inputs and return an output.
- Evolutionary Algorithm: This is analogous to the environment that the phenotypes live in. The Evolutionary algorithm of NEAT tracks each genotype and assigns it to a species. The Evolutionary algorithm also chooses which genotypes can reproduce to create the next generation.

In GoEvo, there is only one genotype implementation, but there are many alternative evolutionary algorithm implementations, including the original NEAT one.

## Example Genotype
Below is a visualisation (generated by the `Draw()` method) of a genotype that was evolved to solve the XOR problem. Data flows from right to left in this drawing. Green nodes represent input neurons, black nodes are hidden neurons, and red nodes are outputs.
Each node has a unique ID (`N301` for example), an execution order (`[4]`), and an activation (`tanh`). Synapses, represented by arrows, each have a weight, which in this instance was capped between -3 and 3.

![xor_pic](./README_ASSETS/xor_net.png)

You may have noticed that there are three inputs, instead of the two you would expect. This is because NEAT networks you need to manually add a bias by appending an additional `1` onto the end of the input sequence. In this case, the bias node, represented as `N3`, is actually not connected to any other nodes, suggesting that it was not necessary.

To validate the network does indeed work, I hardcoded the evolved network quickly in python, in the file README_ASSETS/xor.py. You can see that the network does in fact perform an XOR operation.

## GoEvo Features
- Fast gene mutation and crossover
- Efficient execution of genes by first _compiling_ them into a Phenotype
- Both forward and recurrent connections supported
- Hidden neurons can each have different activations
- Supports many types of genetic algorithms for evolving Genotypes
- Easy saving and loading of genotypes using json
- Supports drawing genotypes to an image using graphviz

## Future Work
- HyperNEAT: I already implemented this in the original package before I rewrote it, so this should be trivial. HyperNEAT basically allows NEAT to evolve much larger networks.
- Implement NEAT algorithm: This should be coming very soon, as I just need to convert the code from the original into this package. Currently, there is a simple population.
- Document EVERYTHING
- Examples directory
- More Tests
- Implement a second phenotype that propagates one neuron per timestep. This is possibly the original way that it was done.